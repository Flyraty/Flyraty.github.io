---
title: 每周刷题_202010_26_1101（WIP）
categories: 算法
tags: leetcode
abbrlink: 8a77d52a
date: 2020-11-01 22:26:48
---

#### 前言
每月从困难题开始到困难题结束。
[二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)
[独一无二的出现次数](https://leetcode-cn.com/problems/unique-number-of-occurrences/)
[连续出现的数字](https://leetcode-cn.com/problems/consecutive-numbers/)
[超过经理收入的员工](https://leetcode-cn.com/problems/employees-earning-more-than-their-managers/)
[查找重复的电子邮箱](https://leetcode-cn.com/problems/duplicate-emails/)
[从不订购的客户](https://leetcode-cn.com/problems/customers-who-never-order/)
[求根到叶子节点数字之和](https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/)
[部门工资最高的员工](https://leetcode-cn.com/problems/department-highest-salary/)
[岛屿的周长](https://leetcode-cn.com/problems/island-perimeter/)
[O(1) 时间插入、删除和获取随机元素 - 允许重复](https://leetcode-cn.com/problems/insert-delete-getrandom-o1-duplicates-allowed/)
[单词拆分 II](https://leetcode-cn.com/problems/word-break-ii/)
<!--more-->

####

- 二叉树的前序遍历
递归方式比较简单，容易理解，也是解决树相关问题最常用的方法。循环迭代的方式实际上就是我们自己实现递归出栈入栈。
```python3
def preorder(root):
	res = []
	stack = []
	while (root or stack):
		if root:
			res.append(root.val)
			stack.append(root)
			root = root.left
		else:
			root = stack.pop().right
	return res			

```

- 
